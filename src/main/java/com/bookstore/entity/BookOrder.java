package com.bookstore.entity;
// Generated May 22, 2018 5:46:15 AM by Hibernate Tools 5.2.10.Final

import java.util.Date;
import java.util.HashSet;
import java.util.Locale;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import static javax.persistence.GenerationType.IDENTITY;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;

/**
 * BookOrder generated by hbm2java
 */
@Entity // 엔티티 클래스임을 나타내는 어노테이션
@Table(name = "book_order", catalog = "bookstoredb") // 엔티티가 매핑되는 테이블 및 카탈로그 이름 지정
@NamedQueries({ // 명명된 쿼리들을 정의하기 위한 어노테이션
    @NamedQuery(name = "BookOrder.findAll", query = "SELECT bo FROM BookOrder bo ORDER BY bo.orderDate DESC"), // 모든 주문을 최신 순으로 조회하는 쿼리
    @NamedQuery(name = "BookOrder.countAll", query = "SELECT COUNT(*) FROM BookOrder"), // 전체 주문 수를 조회하는 쿼리
    @NamedQuery(name = "BookOrder.findByCustomer", // 특정 고객의 주문을 조회하는 쿼리
            query = "SELECT bo FROM BookOrder bo WHERE bo.customer.customerId =:customerId ORDER BY bo.orderDate DESC"),
    @NamedQuery(name = "BookOrder.findByIdAndCustomer", // 특정 orderId와 customerId에 해당하는 주문을 조회하는 쿼리
            query = "SELECT bo FROM BookOrder bo WHERE bo.orderId =:orderId AND bo.customer.customerId =:customerId"),
	 // BookOrder 엔티티에 대한 이름이 "BookOrder.countByCustomer"로 지정된 Named Query입니다.
	 // 이 이름은 나중에 EntityManager에서 해당 쿼리를 참조할 때 사용됩니다.
	 @NamedQuery(name = "BookOrder.countByCustomer",
	             query = "SELECT COUNT(bo.orderId) FROM BookOrder bo WHERE bo.customer.customerId = :customerId")
//위의 코드에서 사용된 @NamedQuery 어노테이션은 JPA(Java Persistence API)에서 Named Query를 정의할 때 사용됩니다. "BookOrder.countByCustomer"이라는 이름으로 쿼리가 등록되며, 이 쿼리는 BookOrder 엔티티에서 customerId를 기반으로 해당 고객과 연관된 주문의 수를 가져옵니다. "bo"는 BookOrder 엔티티를 나타내는 별칭(alias)이며, :customerId는 미리 정의된 파라미터로, 추후에 이 값이 바인딩됩니다.
})

//@Entity: 엔티티 클래스임을 표시하는 JPA 어노테이션입니다. 해당 클래스가 데이터베이스의 엔티티와 매핑됨을 나타냅니다.
//@Table(name = "book_order", catalog = "bookstoredb"): 엔티티 클래스가 매핑되는 테이블과 카탈로그 이름을 지정합니다. book_order 테이블을 bookstoredb 카탈로그에 매핑합니다.
//@NamedQueries({ ... }): 명명된 쿼리를 정의하기 위한 어노테이션으로, 각각의 Named Query들을 정의합니다.
//@NamedQuery(name = "BookOrder.findAll", query = "SELECT bo FROM BookOrder bo ORDER BY bo.orderDate DESC"): "BookOrder.findAll"이라는 이름의 쿼리를 정의합니다. 이 쿼리는 모든 주문을 최신 순으로 조회합니다.
//@NamedQuery(name = "BookOrder.countAll", query = "SELECT COUNT(*) FROM BookOrder"): "BookOrder.countAll"이라는 이름의 쿼리를 정의합니다. 이 쿼리는 전체 주문 수를 조회합니다.
//@NamedQuery(name = "BookOrder.findByCustomer", query = "SELECT bo FROM BookOrder bo WHERE bo.customer.customerId =:customerId ORDER BY bo.orderDate DESC"): "BookOrder.findByCustomer"이라는 이름의 쿼리를 정의합니다. 이 쿼리는 특정 고객의 주문을 고객 ID로 조회하고 최신 순으로 정렬합니다.
//@NamedQuery(name = "BookOrder.findByIdAndCustomer", query = "SELECT bo FROM BookOrder bo WHERE bo.orderId =:orderId AND bo.customer.customerId =:customerId"): "BookOrder.findByIdAndCustomer"이라는 이름의 쿼리를 정의합니다. 이 쿼리는 특정 orderId와 customerId에 해당하는 주문을 조회합니다.
//이러한 명명된 쿼리들은 각각의 이름으로 호출될 수 있으며, 해당 이름으로 정의된 쿼리를 JPA에서 실행할 수 있습니다. 이는 보다 간편하고 유지보수가 용이한 쿼리 실행 방식을 제공합니다.

public class BookOrder implements java.io.Serializable {

	private Integer orderId;
	private Customer customer;
	private Date orderDate;
	private String addressLine1;
	private String addressLine2;
	private String firstname;
	private String lastname;
	private String phone;
	private String city;
	private String state;
	private String zipcode;
	private String country;
	private String paymentMethod;
	
	private float total;
	private float subtotal;
	private float shippingFee;
	private float tax;
	
	private String status;
	
	private Set<OrderDetail> orderDetails = new HashSet<OrderDetail>(0);
	// 'orderDetails'는 'OrderDetail' 엔티티를 저장하는데 사용되는 HashSet입니다.
	// 'OrderDetail'은 'BookOrder' 엔티티와 관련이 있을 가능성이 있습니다. 여러 주문 세부사항을 관리하기 위한 것으로 보입니다.

	public BookOrder() {
	}
	// 기본 생성자입니다. 아마도 JPA(Java Persistence API)나 기타 프레임워크에서 객체를 생성하기 위해 필요한 것으로 보입니다.

	@Column(name = "r_address_line2", nullable = true, length = 256)
	// 이 어노테이션은 'addressLine2' 필드가 데이터베이스의 "r_address_line2" 컬럼에 매핑되도록 지정합니다.
	// 'addressLine2'는 주문의 두 번째 주소 라인을 나타냅니다. 'nullable = false'는 null 값을 허용하지 않음을 의미하고,
	// 'length = 256'은 데이터베이스에 저장할 수 있는 최대 길이를 나타냅니다.

	public String getAddressLine2() {
		return addressLine2;
	}
	// 'addressLine2' 필드의 값을 반환하는 getter 메서드입니다.

	public void setAddressLine2(String addressLine2) {
		this.addressLine2 = addressLine2;
	}
	// 'addressLine2' 필드의 값을 설정하는 setter 메서드입니다.

	@Column(name = "r_lastname", nullable = false, length = 30)
	// 이 어노테이션은 'lastname' 필드가 데이터베이스의 "r_lastname" 컬럼에 매핑되도록 지정합니다.
	// 'lastname'는 주문자의 성(last name)을 나타냅니다. 'nullable = false'는 null 값을 허용하지 않음을 의미하고,
	// 'length = 30'은 데이터베이스에 저장할 수 있는 최대 길이를 나타냅니다.

	public String getLastname() {
		return lastname;
	}
	// 'lastname' 필드의 값을 반환하는 getter 메서드입니다.

	public void setLastname(String lastname) {
		this.lastname = lastname;
	}
	// 'lastname' 필드의 값을 설정하는 setter 메서드입니다.

	@Column(name = "r_phone", nullable = false, length = 15)
	// 'r_phone'은 데이터베이스의 "r_phone" 컬럼에 매핑됩니다.
	// 'phone'은 주문자의 전화번호를 나타내며, 'nullable = false'는 null 값을 허용하지 않음을 나타냅니다.
	// 'length = 15'는 데이터베이스에 저장할 수 있는 최대 길이를 나타냅니다. 전화번호의 길이가 15자를 초과할 수 없습니다.

	public String getPhone() {
		return phone;
	}
	// 'phone' 필드의 값을 반환하는 getter 메서드입니다.

	public void setPhone(String phone) {
		this.phone = phone;
	}
	// 'phone' 필드의 값을 설정하는 setter 메서드입니다.

	@Column(name = "r_city", nullable = false, length = 32)	
	// 'r_city'는 데이터베이스의 "r_city" 컬럼에 매핑됩니다.
	// 'city'는 주문자의 도시 정보를 나타내며, 'nullable = false'는 null 값을 허용하지 않음을 의미합니다.
	// 'length = 32'는 데이터베이스에 저장할 수 있는 최대 길이를 나타냅니다. 도시 정보의 길이가 32자를 초과할 수 없습니다.

	public String getCity() {
		return city;
	}
	// 'city' 필드의 값을 반환하는 getter 메서드입니다.

	public void setCity(String city) {
		this.city = city;
	}
	// 'city' 필드의 값을 설정하는 setter 메서드입니다.

	@Column(name = "r_state", nullable = false, length = 45)	
	// 'r_state'는 데이터베이스의 "r_state" 컬럼에 매핑됩니다.
	// 'state'는 주문자의 주(state) 정보를 나타내며, 'nullable = false'는 null 값을 허용하지 않음을 의미합니다.
	// 'length = 45'는 데이터베이스에 저장할 수 있는 최대 길이를 나타냅니다. 주(state) 정보의 길이가 45자를 초과할 수 없습니다.

	public String getState() {
		return state;
	}
	// 'state' 필드의 값을 반환하는 getter 메서드입니다.

	public void setState(String state) {
		this.state = state;
	}
	// 'state' 필드의 값을 설정하는 setter 메서드입니다.

//위 코드는 'BookOrder' 클래스에 있는 세 개의 필드를 나타내고 있습니다. 각 필드는 데이터베이스 테이블에 매핑되고, 해당하는 주문자의 전화번호, 도시 정보, 주(state) 정보를 저장합니다. 'get' 메서드는 해당 필드의 값을 반환하고, 'set' 메서드는 해당 필드의 값을 설정합니다. 'Column' 어노테이션은 각 필드가 데이터베이스의 특정 컬럼에 매핑되도록 지정합니다. 'nullable = false'는 해당 필드가 null 값을 허용하지 않음을 나타냅니다. 'length'는 각 필드가 저장될 수 있는 최대 길이를 나타냅니다.

	@Column(name = "r_zipcode", nullable = false, length = 24)	
	// 'r_zipcode'는 데이터베이스의 "r_zipcode" 컬럼에 매핑됩니다.
	// 'zipcode'는 주문자의 우편번호를 나타내며, 'nullable = false'는 null 값을 허용하지 않음을 의미합니다.
	// 'length = 24'는 데이터베이스에 저장할 수 있는 최대 길이를 나타냅니다. 우편번호의 길이가 24자를 초과할 수 없습니다.

	public String getZipcode() {
		return zipcode;
	}
	// 'zipcode' 필드의 값을 반환하는 getter 메서드입니다.

	public void setZipcode(String zipcode) {
		this.zipcode = zipcode;
	}
	// 'zipcode' 필드의 값을 설정하는 setter 메서드입니다.

	@Column(name = "r_country", nullable = false, length = 4)	
	// 'r_country'는 데이터베이스의 "r_country" 컬럼에 매핑됩니다.
	// 'country'는 주문자의 국가를 나타내며, 'nullable = false'는 null 값을 허용하지 않음을 의미합니다.
	// 'length = 4'는 데이터베이스에 저장할 수 있는 최대 길이를 나타냅니다. 국가 정보의 길이가 4자를 초과할 수 없습니다.

	public String getCountry() {
		return country;
	}
	// 'country' 필드의 값을 반환하는 getter 메서드입니다.

	public void setCountry(String country) {
		this.country = country;
	}
	// 'country' 필드의 값을 설정하는 setter 메서드입니다.

	@Transient
	// 'Transient' 어노테이션은 해당 필드가 데이터베이스에 매핑되지 않음을 나타냅니다.
	// 'getCountryName' 메서드는 'country' 필드에 해당하는 국가 코드를 이용하여 국가명을 반환합니다.
	// 이 메서드는 데이터베이스에 저장되지 않으며 필요할 때만 국가명을 동적으로 생성하여 반환합니다.

	public String getCountryName() {
		return new Locale("", this.country).getDisplayCountry();
	}
	// 'country' 필드에 해당하는 국가 코드를 이용하여 국가명을 반환하는 메서드입니다.

	@Column(name = "subtotal", nullable = false, precision = 12, scale = 0)	
	// 'subtotal'은 데이터베이스의 "subtotal" 컬럼에 매핑됩니다.
	// 'subtotal'은 주문의 부분 합계(subtotal)를 나타내며, 'nullable = false'는 null 값을 허용하지 않음을 의미합니다.
	// 'precision = 12'는 소수점 이하 자릿수를 포함한 전체 자릿수를 나타내며, 'scale = 0'은 소수점 이하 자릿수를 의미합니다.

	public float getSubtotal() {
		return subtotal;
	}
	// 'subtotal' 필드의 값을 반환하는 getter 메서드입니다.

	public void setSubtotal(float subtotal) {
		this.subtotal = subtotal;
	}
	// 'subtotal' 필드의 값을 설정하는 setter 메서드입니다.

// 위 코드는 'BookOrder' 클래스에 있는 다양한 필드와 메서드를 나타내고 있습니다. 'r_zipcode'와 'r_country' 컬럼은 각각 주문자의 우편번호와 국가 정보를 저장하며, 'nullable = false'는 null 값을 허용하지 않음을 나타냅니다. 'length'는 데이터베이스에 저장할 수 있는 최대 길이를 나타냅니다. 'getCountryName' 메서드는 'country' 필드에 해당하는 국가 코드를 사용하여 국가명을 반환하는 메서드입니다. 'subtotal'은 주문의 부분 합계를 나타내며, 'precision'은 전체 자릿수를, 'scale'은 소수점 이하 자릿수를 의미합니다.	
	
	
	@Column(name = "shipping_fee", nullable = false, precision = 12, scale = 0)	
	// 'shipping_fee'는 데이터베이스의 "shipping_fee" 컬럼에 매핑됩니다.
	// 'shippingFee'는 주문의 배송비(shipping fee)를 나타내며, 'nullable = false'는 null 값을 허용하지 않음을 의미합니다.
	// 'precision = 12'는 소수점 이하 자릿수를 포함한 전체 자릿수를 나타내며, 'scale = 0'은 소수점 이하 자릿수를 의미합니다.

	public float getShippingFee() {
		return shippingFee;
	}
	// 'shippingFee' 필드의 값을 반환하는 getter 메서드입니다.

	public void setShippingFee(float shippingFee) {
		this.shippingFee = shippingFee;
	}
	// 'shippingFee' 필드의 값을 설정하는 setter 메서드입니다.

	@Column(name = "tax", nullable = false, precision = 12, scale = 0)	
	// 'tax'는 데이터베이스의 "tax" 컬럼에 매핑됩니다.
	// 'tax'는 주문의 세금(tax)을 나타내며, 'nullable = false'는 null 값을 허용하지 않음을 의미합니다.
	// 'precision = 12'는 소수점 이하 자릿수를 포함한 전체 자릿수를 나타내며, 'scale = 0'은 소수점 이하 자릿수를 의미합니다.

	public float getTax() {
		return tax;
	}
	// 'tax' 필드의 값을 반환하는 getter 메서드입니다.

	public void setTax(float tax) {
		this.tax = tax;
	}
	// 'tax' 필드의 값을 설정하는 setter 메서드입니다.


	public BookOrder(Customer customer, Date orderDate, String shippingAddress, String recipientName,
	        String recipientPhone, String paymentMethod, float total, String status) {
	    this.customer = customer; // 주문을 생성하는 고객 객체(Customer)를 설정합니다.
	    this.orderDate = orderDate; // 주문 생성 일자를 설정합니다.
	    this.addressLine1 = shippingAddress; // 배송 주소의 첫 번째 라인을 설정합니다.
	    this.firstname = recipientName; // 수취인의 이름을 설정합니다.
	    this.phone = recipientPhone; // 수취인의 전화번호를 설정합니다.
	    this.paymentMethod = paymentMethod; // 결제 방법을 설정합니다.
	    this.total = total; // 주문 총액을 설정합니다.
	    this.status = status; // 주문 상태를 설정합니다.
	}

	public BookOrder(Customer customer, Date orderDate, String shippingAddress, String recipientName,
	        String recipientPhone, String paymentMethod, float total, String status, Set<OrderDetail> orderDetails) {
	    this.customer = customer; // 주문을 생성하는 고객 객체(Customer)를 설정합니다.
	    this.orderDate = orderDate; // 주문 생성 일자를 설정합니다.
	    this.addressLine1 = shippingAddress; // 배송 주소의 첫 번째 라인을 설정합니다.
	    this.firstname = recipientName; // 수취인의 이름을 설정합니다.
	    this.phone = recipientPhone; // 수취인의 전화번호를 설정합니다.
	    this.paymentMethod = paymentMethod; // 결제 방법을 설정합니다.
	    this.total = total; // 주문 총액을 설정합니다.
	    this.status = status; // 주문 상태를 설정합니다.
	    this.orderDetails = orderDetails; // 주문에 속한 세부 주문 내역(OrderDetail)을 설정합니다.
	}
// 위 코드는 BookOrder 클래스의 생성자 두 개를 나타냅니다. 첫 번째 생성자는 주문(order)을 나타내는 BookOrder 객체를 생성하며, 고객(Customer)의 정보, 주문 날짜, 배송 주소, 수취인 정보, 결제 방법, 주문 총액, 주문 상태를 받아와 해당 필드들을 초기화합니다. 두 번째 생성자는 첫 번째 생성자와 동일한 필드들을 초기화하며, 추가로 세부 주문 내역(orderDetails)을 받아 해당 필드도 초기화합니다.
	
	@Id // 데이터베이스의 엔티티에서 해당 필드가 기본 키(primary key)임을 나타냅니다.
	@GeneratedValue(strategy = IDENTITY) // 기본 키 값의 생성 전략을 지정합니다.
	@Column(name = "order_id", unique = true, nullable = false) // order_id 열과 매핑하며, 고유하고 null 값을 허용하지 않습니다.
	public Integer getOrderId() {
	    return this.orderId; // orderId 속성 값을 반환하는 getter 메서드입니다.
	}

	public void setOrderId(Integer orderId) {
	    this.orderId = orderId; // orderId 속성 값을 설정하는 setter 메서드입니다.
	}

//	@Id: 해당 필드가 엔티티의 기본 키(primary key)임을 나타냅니다.
//	@GeneratedValue(strategy = IDENTITY): 기본 키 값의 생성 전략을 지정합니다. 여기서는 데이터베이스에서 값을 생성하도록 지정되어 있습니다.
//	@Column(name = "order_id", unique = true, nullable = false): 필드를 데이터베이스의 열(column)과 매핑합니다. 여기서는 order_id 열이 고유(unique)하며 데이터베이스에 null 값을 허용하지 않음을 명시합니다.
//	public Integer getOrderId() {...}: orderId 속성 값을 반환하는 getter 메서드입니다.
//	public void setOrderId(Integer orderId) {...}: orderId 속성 값을 설정하는 setter 메서드입니다.
//	이 코드는 엔티티의 기본 키인 order_id와 해당 클래스 내의 orderId 필드를 매핑합니다. @Id 어노테이션은 기본 키임을 나타내고, @GeneratedValue는 기본 키 값의 생성 전략을 지정합니다. @Column은 데이터베이스의 열과 해당 필드를 매핑하며, getter와 setter 메서드는 해당 필드에 접근하고 값을 설정하는 데 사용됩니다.

	@ManyToOne(fetch = FetchType.EAGER) // 매핑된 엔티티가 다대일(N:1) 관계이며, 즉시 로딩(fetch = FetchType.EAGER)을 수행합니다.
	@JoinColumn(name = "customer_id", nullable = false) // customer_id 컬럼과 매핑되며, null 값을 허용하지 않습니다.
	public Customer getCustomer() {
	    return this.customer; // 현재 엔티티의 고객 정보를 반환하는 getter 메서드입니다.
	}

	public void setCustomer(Customer customer) {
	    this.customer = customer; // 현재 엔티티의 고객 정보를 설정하는 setter 메서드입니다.
	}

//@ManyToOne(fetch = FetchType.EAGER)는 현재 엔티티와 Customer 엔티티 간의 다대일(N:1) 관계를 나타내며, FetchType.EAGER를 사용하여 관련된 Customer를 즉시 로딩합니다. @JoinColumn(name = "customer_id", nullable = false)은 customer_id 컬럼과 현재 엔티티를 매핑하며, null 값을 허용하지 않습니다. Getter와 Setter 메서드는 현재 엔티티의 고객 정보를 반환하고 설정하는 데 사용됩니다.
	
	@Temporal(TemporalType.TIMESTAMP) // order_date 필드에 TemporalType.TIMESTAMP 유형의 시간 정보를 저장합니다.
	@Column(name = "order_date", nullable = false, length = 19) // order_date 컬럼을 매핑하며, null 값을 허용하지 않습니다. 길이는 19입니다.
	public Date getOrderDate() {
	    return this.orderDate; // 현재 엔티티의 주문 날짜를 반환하는 getter 메서드입니다.
	}

	public void setOrderDate(Date orderDate) {
	    this.orderDate = orderDate; // 현재 엔티티의 주문 날짜를 설정하는 setter 메서드입니다.
	}
//@Temporal(TemporalType.TIMESTAMP)은 엔티티 클래스의 order_date 필드가 날짜와 시간 정보를 저장하며, TemporalType.TIMESTAMP로 설정된 것을 나타냅니다. @Column(name = "order_date", nullable = false, length = 19)은 order_date 컬럼과 매핑되며, null 값을 허용하지 않고 길이는 19입니다. Getter 메서드는 현재 엔티티의 주문 날짜를 반환하고, Setter 메서드는 주문 날짜를 설정합니다

	@Column(name = "r_address_line1", nullable = false, length = 256) // r_address_line1 컬럼을 매핑하며, null 값을 허용하지 않고 길이는 256입니다.
	public String getAddressLine1() {
	    return this.addressLine1; // 현재 엔티티의 주소 라인 1을 반환하는 getter 메서드입니다.
	}

	public void setAddressLine1(String addressLine1) {
	    this.addressLine1 = addressLine1; // 현재 엔티티의 주소 라인 1을 설정하는 setter 메서드입니다.
	}
	
//	@Column(name = "r_address_line1", nullable = false, length = 256)은 엔티티 클래스의 r_address_line1 필드를 매핑하며, null 값을 허용하지 않으며 길이는 256입니다. Getter 메서드는 현재 엔티티의 주소 라인 1을 반환하고, Setter 메서드는 주소 라인 1을 설정합니다.

	@Column(name = "r_firstname", nullable = false, length = 30) // r_firstname 컬럼을 매핑하며, null 값을 허용하지 않고 길이는 30입니다.
	public String getFirstname() {
	    return this.firstname; // 현재 엔티티의 이름을 반환하는 getter 메서드입니다.
	}

	public void setFirstname(String firstname) {
	    this.firstname = firstname; // 현재 엔티티의 이름을 설정하는 setter 메서드입니다.
	}
//	@Column(name = "r_firstname", nullable = false, length = 30)은 엔티티 클래스의 r_firstname 필드를 매핑하며, null 값을 허용하지 않으며 길이는 30입니다. Getter 메서드는 현재 엔티티의 이름을 반환하고, Setter 메서드는 이름을 설정합니다.

	@Column(name = "payment_method", nullable = false, length = 20) // payment_method 컬럼을 매핑하며, null 값을 허용하지 않고 길이는 20입니다.
	public String getPaymentMethod() {
	    return this.paymentMethod; // 현재 엔티티의 결제 방법을 반환하는 getter 메서드입니다.
	}

	public void setPaymentMethod(String paymentMethod) {
	    this.paymentMethod = paymentMethod; // 현재 엔티티의 결제 방법을 설정하는 setter 메서드입니다.
	}

	@Column(name = "total", nullable = false, precision = 12, scale = 0) // total 컬럼을 매핑하며, null 값을 허용하지 않고, 소수점 이하 자릿수는 0이며, 전체 자릿수는 12입니다.
	public float getTotal() {
	    return this.total; // 현재 엔티티의 총액을 반환하는 getter 메서드입니다.
	}

	public void setTotal(float total) {
	    this.total = total; // 현재 엔티티의 총액을 설정하는 setter 메서드입니다.
	}

	@Column(name = "status", nullable = false, length = 20) // status 컬럼을 매핑하며, null 값을 허용하지 않고 길이는 20입니다.
	public String getStatus() {
	    return this.status; // 현재 엔티티의 상태를 반환하는 getter 메서드입니다.
	}

	public void setStatus(String status) {
	    this.status = status; // 현재 엔티티의 상태를 설정하는 setter 메서드입니다.
	}
//위 코드는 @Column 어노테이션을 사용하여 엔티티 클래스의 필드를 테이블의 컬럼과 매핑합니다. getPaymentMethod()은 현재 엔티티의 결제 방법을 반환하고, setPaymentMethod()는 결제 방법을 설정합니다. getTotal()은 엔티티의 총액을 반환하고, setTotal()은 총액을 설정합니다. 마지막으로 getStatus()는 엔티티의 상태를 반환하고, setStatus()는 상태를 설정합니다.

	@OneToMany(fetch = FetchType.EAGER, mappedBy = "bookOrder", cascade = CascadeType.ALL, orphanRemoval = true)
	public Set<OrderDetail> getOrderDetails() {
	    return this.orderDetails; // 현재 엔티티의 주문 상세 정보를 담은 컬렉션을 반환하는 getter 메서드입니다.
	}

	public void setOrderDetails(Set<OrderDetail> orderDetails) {
	    this.orderDetails = orderDetails; // 현재 엔티티의 주문 상세 정보를 설정하는 setter 메서드입니다.
	}
	
//	위 코드는 @OneToMany 어노테이션을 사용하여 일대다 관계를 매핑합니다. 현재 엔티티에는 여러 개의 OrderDetail이 있을 수 있습니다. getOrderDetails()는 현재 엔티티의 주문 상세 정보를 담은 컬렉션을 반환합니다. setOrderDetails()는 현재 엔티티의 주문 상세 정보를 설정합니다. mappedBy = "bookOrder"는 OrderDetail 엔티티의 bookOrder 필드를 기반으로 매핑한다는 것을 나타냅니다. cascade = CascadeType.ALL은 연관된 엔티티에 대한 모든 변경 사항이 이 엔티티에 전파되도록 합니다. orphanRemoval = true는 부모와의 관계가 끊어지면 해당 자식 엔티티가 삭제되도록 설정합니다.
	
	@Transient
	public int getBookCopies() { 
//getBookCopies(): 현재 주문에 속한 주문 상세 정보들의 수량을 합산하여 총 수량을 반환합니다.
	    int total = 0; // 주문에 속한 모든 주문 상세 정보의 총 수량을 담을 변수 초기화
	    
	    for (OrderDetail orderDetail : orderDetails) { // 주문 상세 정보를 반복하여 수량을 합산
	        total += orderDetail.getQuantity(); // 주문 상세 정보의 수량을 총 수량에 더함
	    }
	    
	    return total; // 총 수량 반환
	}

	@Override
	public int hashCode() {
//hashCode(): 객체의 해시코드를 생성합니다. orderId를 기반으로 해시코드를 생성하여 반환합니다.
	    final int prime = 31; // 해시코드를 생성하는 데 사용되는 상수값
	    int result = 1; // 초기 해시코드 값 설정
	    result = prime * result + ((orderId == null) ? 0 : orderId.hashCode()); // orderId를 기반으로 한 해시코드 계산
	    return result; // 최종적으로 계산된 해시코드 반환
	}

	@Override
	public boolean equals(Object obj) {
//equals(): 두 BookOrder 객체가 동일한지 여부를 확인합니다. orderId를 비교하여 두 객체가 동일한지 여부를 반환합니다.
	    if (this == obj) // 객체가 자기 자신과 같은 경우
	        return true; // true 반환
	    if (obj == null) // 비교할 객체가 null인 경우
	        return false; // false 반환
	    if (getClass() != obj.getClass()) // 비교하는 객체의 클래스가 현재 객체의 클래스와 다른 경우
	        return false; // false 반환
	    BookOrder other = (BookOrder) obj; // 형변환 수행
	    if (orderId == null) { // 현재 객체의 orderId가 null인 경우
	        if (other.orderId != null) // 비교하는 객체의 orderId가 null이 아닌 경우
	            return false; // false 반환
	    } else if (!orderId.equals(other.orderId)) // orderId 값이 서로 다른 경우
	        return false; // false 반환
	    return true; // 모든 조건에 해당하지 않는 경우 true 반환
	}


	
}
